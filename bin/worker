#!/usr/bin/env php
<?php
/**
 * Work handles receiving queued jobs, and passing them along to a worker handler in the service
 */

// Setup autoloader
include(__DIR__ . "/../vendor/autoload.php");

use Aereus\Config\ConfigLoader;
use Netric\WorkerMan\Worker\AccountBillingWorker;
use Netric\WorkerMan\Worker\EntityDefinitionPostSaveWorker;
use Netric\WorkerMan\Worker\EntityPostSaveWorker;
use Netric\WorkerMan\Worker\EntitySyncSetExportedStaleWorker;
use Netric\WorkerMan\Worker\NotificationWorker;
use Netric\WorkerMan\Worker\ScheduleRunnerWorker;
use Netric\WorkerMan\Worker\TestWorker;
use Netric\WorkerMan\Worker\WorkflowWaitActionWorker;
use NetricApi\WorkerClient;
use Thrift\Exception\TApplicationException;
use Thrift\Protocol\TBinaryProtocol;
use Thrift\Transport\TBufferedTransport;
use Thrift\Transport\THttpClient;

ini_set("display_errors", "On");
ini_set("memory_limit", "2G");

// chdir to the root
chdir(dirname(__DIR__));

$configLoader = new ConfigLoader();
$applicationEnvironment = (getenv('APPLICATION_ENV')) ? getenv('APPLICATION_ENV') : "production";

// Setup the new config
$config = $configLoader->fromFolder(__DIR__ . "/../config", $applicationEnvironment);

// Wait for server to come online
for ($i = 0; $i < 60; $i++) {
    if (isServiceAvailable("http://" . gethostbyname($config->workers->service_name) . "/api/v1/health/ping")) {
        break;
    }
    echo "Waiting for service $i of 60...\n";
    sleep(1);
}

// Setup thrift client to make calls
$socket = new THttpClient(gethostbyname($config->workers->service_name), 80, '/thrift/worker');
$transport = new TBufferedTransport($socket);
$protocol = new TBinaryProtocol($transport);

// Setup gearman
$gmWorker = new GearmanWorker();
$gmWorker->addServer($config->workers->worker_gearman, 4730);

// Worker functions we are interested in
$listeningFunctions = [
    AccountBillingWorker::class,
    EntityPostSaveWorker::class,
    NotificationWorker::class,
    ScheduleRunnerWorker::class,
    TestWorker::class,
    WorkflowWaitActionWorker::class,
    EntitySyncSetExportedStaleWorker::class,
    EntityDefinitionPostSaveWorker::class,
    "CronMinutely"
];

foreach ($listeningFunctions as $functionName) {
    $gmWorker->addFunction($functionName, "processJob");
}

/**
 * FUnction will be used to process all jobs as they come in
 * 
 * @param GearmanJob $job 
 * @return bool 
 * @throws TApplicationException 
 * @throws Exception 
 */
function processJob(GearmanJob $job)
{
    global $protocol, $config;
    echo "WORKER: " . $job->functionName() . "\n";

    $postData = json_encode([
        'worker_name' => $job->functionName(),
        'payload' => $job->workload(),
    ]);
    $ch = curl_init(gethostbyname($config->workers->service_name) . "/api/v2/workers/process");
    curl_setopt($ch, CURLOPT_POST, 1);
    curl_setopt($ch, CURLOPT_POSTFIELDS, $postData);
    curl_setopt($ch, CURLOPT_RETURNTRANSFER, 1);
    curl_setopt($ch, CURLOPT_HTTPHEADER, ['Content-Type: application/json']);
    $result = curl_exec($ch);
    curl_close($ch);

    if (curl_errno($ch)) {
        $info = curl_getinfo($ch);
        echo "Opps. Error: " . var_export($result, true);
        return false;
    }

    return true;
    // $client = new WorkerClient($protocol);
    // try {
    //     return $client->process($job->functionName(), $job->workload());
    // } catch (Exception $ex) {
    //     echo "Opps. Error: " . $ex->getMessage();
    //     return false;
    // }
}

/**
 * Basic function used to see if netric is online
 *
 * @param mixed $url 
 * @return bool 
 */
function isServiceAvailable($url)
{
    // Check, if a valid url is provided
    if (!filter_var($url, FILTER_VALIDATE_URL)) {
        return false;
    }

    // Initialize cURL
    $curlInit = curl_init($url);

    // Set options
    curl_setopt($curlInit, CURLOPT_CONNECTTIMEOUT, 10);
    curl_setopt($curlInit, CURLOPT_HEADER, true);
    curl_setopt($curlInit, CURLOPT_NOBODY, true);
    curl_setopt($curlInit, CURLOPT_RETURNTRANSFER, true);

    // Get response
    $response = curl_exec($curlInit);

    // Close a cURL session
    curl_close($curlInit);

    return $response ? true : false;
}

while ($gmWorker->work()) {
    if ($gmWorker->returnCode() != GEARMAN_SUCCESS) {
        error_log("WORKER ERROR: " . $gmWorker->returnCode());
        break;
    }
}
